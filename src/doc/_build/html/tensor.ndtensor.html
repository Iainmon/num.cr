<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>The N-dimensional tensor &mdash; Bottle 0.2.2 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="Bottle 0.2.2 documentation" href="index.html" >
    <link rel="up" title="Tensor objects" href="tensor.html" >
    <link rel="prev" title="Tensor objects" href="tensor.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="["></a></li>
        <li class="active"><a href="]"></a></li>
	
        <li class="active"><a href="index.html">Bottle 0.2.2 documentation</a></li>
	
          <li class="active"><a href="tensor.html" accesskey="U">Tensor objects</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="tensor.html" title="Tensor objects"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="the-n-dimensional-tensor">
<span id="tensor-ndtensor"></span><h1>The N-dimensional tensor<a class="headerlink" href="#the-n-dimensional-tensor" title="Permalink to this headline">¶</a></h1>
<p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">tensor</span></code> is a (usually fixed-size) multidimensional
container of items of the same type and size. The number of dimensions
and items in an array is defined by its <code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code>,
which is a <code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> of <em>N</em> non-negative integers that specify the
sizes of each dimension. The type of items in the array is specified by
a separate <span class="xref std std-ref">data-type object</span>, one of which
is associated with each Tensor.</p>
<p>As with other container objects in Crystal, the contents of an
<code class="xref py py-class docutils literal notranslate"><span class="pre">tensor</span></code> can be accessed and modified by <span class="xref std std-ref">indexing or
slicing</span> the tensor (using, for example, <em>N</em> integers),
and via the methods and attributes of the <code class="xref py py-class docutils literal notranslate"><span class="pre">tensor</span></code>.</p>
<p id="index-0">Different <code class="xref py py-class docutils literal notranslate"><span class="pre">tensors</span></code> can share the same data, so that
changes made in one <code class="xref py py-class docutils literal notranslate"><span class="pre">tensor</span></code> may be visible in another. That
is, a tensor can be a <em>“view”</em> to another tensor, and the data it
is referring to is taken care of by the <em>“base”</em> pointer.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>A 2-dimensional tensor of size 2 x 3, composed of 4-byte integer
elements:</p>
</div>
<div class="highlight-crystal notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Tensor</span><span class="o">.</span><span class="n">from_array</span> <span class="o">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">,</span> <span class="o">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="o">]]</span>

<span class="k">typeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># =&gt; Tensor(Int32)</span>

<span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># =&gt; [2, 3]</span>

<span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="c1"># =&gt; Int32</span>
</pre></div>
</div>
<p>The array can be indexed using array-like indexing syntax:</p>
<div class="highlight-crystal notranslate"><div class="highlight"><pre><span></span><span class="c1"># The element of x in the *second* row, *third* column, namely, 6.</span>
<span class="n">x</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">]</span>
</pre></div>
</div>
<p>For example <span class="xref std std-ref">slicing</span> can produce views of
the array:</p>
<div class="highlight-crystal notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">[...</span><span class="p">,</span><span class="mi">1</span><span class="o">]</span>

<span class="nb">puts</span> <span class="n">y</span> <span class="c1"># =&gt; Tensor([2, 5])</span>

<span class="n">y</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">9</span> <span class="c1"># this also changes the corresponding element in x</span>

<span class="nb">puts</span> <span class="n">y</span> <span class="c1"># =&gt; Tensor([9, 5])</span>

<span class="nb">puts</span> <span class="n">x</span> <span class="c1"># =&gt;</span>
<span class="c1"># Tensor([[1, 9, 3],</span>
<span class="c1">#         [4, 5, 6]])</span>
</pre></div>
</div>
<div class="section" id="constructing-tensors">
<h2>Constructing Tensors<a class="headerlink" href="#constructing-tensors" title="Permalink to this headline">¶</a></h2>
<p>New tensors can be constructed using the routines detailed in
<span class="xref std std-ref">routines.tensor-creation</span>, and also by using the low-level
<code class="xref py py-class docutils literal notranslate"><span class="pre">tensor</span></code> constructor:</p>
</div>
<div class="section" id="indexing-arrays">
<span id="tensor-ndtensor-indexing"></span><h2>Indexing arrays<a class="headerlink" href="#indexing-arrays" title="Permalink to this headline">¶</a></h2>
<p>Arrays can be indexed using an extended Crystal slicing syntax,
<code class="docutils literal notranslate"><span class="pre">tensor[selection]</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">Tensor Indexing</span>.</p>
</div>
</div>
<div class="section" id="internal-memory-layout-of-an-tensor">
<span id="memory-layout"></span><h2>Internal memory layout of an Tensor<a class="headerlink" href="#internal-memory-layout-of-an-tensor" title="Permalink to this headline">¶</a></h2>
<p>An instance of class <code class="xref py py-class docutils literal notranslate"><span class="pre">tensor</span></code> consists of a contiguous
one-dimensional segment of computer memory (owned by the tensor, or by
some other tensor), combined with an indexing scheme that maps <em>N</em>
integers into the location of an item in the block.  The ranges in
which the indices can vary is specified by the <code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code> of the array. How many bytes each item takes and how
the bytes are interpreted is defined by the <span class="xref std std-ref">dtype</span> associated with the tensor.</p>
<p id="index-1">A segment of memory is inherently 1-dimensional, and there are many
different schemes for arranging the items of an <em>N</em>-dimensional tensor
in a 1-dimensional block. Bottle is flexible, and <code class="xref py py-class docutils literal notranslate"><span class="pre">tensor</span></code>
objects can accommodate any <em>strided indexing scheme</em>. In a strided
scheme, the N-dimensional index <span class="math notranslate nohighlight">\((n_0, n_1, ..., n_{N-1})\)</span>
corresponds to the offset (in bytes):</p>
<div class="math notranslate nohighlight">
\[n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k\]</div>
<p>from the beginning of the memory block associated with the
tensor. Here, <span class="math notranslate nohighlight">\(s_k\)</span> are integers which specify the <code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code> of the tensor. The <span class="xref std std-term">column-major</span> order (used,
for example, in the Fortran language and in <em>Matlab</em>) and
<span class="xref std std-term">row-major</span> order (used in C) schemes are just specific kinds of
strided scheme, and correspond to memory that can be <em>addressed</em> by the strides:</p>
<div class="math notranslate nohighlight">
\[s_k^{\mathrm{column}} = \mathrm{itemsize} \prod_{j=0}^{k-1} d_j ,
\quad  s_k^{\mathrm{row}} = \mathrm{itemsize} \prod_{j=k+1}^{N-1} d_j .\]</div>
<p id="index-2">where <span class="math notranslate nohighlight">\(d_j\)</span> <cite>= shape[j]</cite>.</p>
<p>Both the C and Fortran orders are <span class="xref std std-term">contiguous</span>, <em>i.e.,</em>
single-segment, memory layouts, in which every part of the
memory block can be accessed by some combination of the indices.</p>
<p>While a C-style and Fortran-style contiguous tensor, which has the corresponding
flags set, can be addressed with the above strides, the actual strides may be
different. This can happen in two cases:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">shape[k]</span> <span class="pre">==</span> <span class="pre">1</span></code> then for any legal index <code class="docutils literal notranslate"><span class="pre">index[k]</span> <span class="pre">==</span> <span class="pre">0</span></code>.
This means that in the formula for the offset <span class="math notranslate nohighlight">\(n_k = 0\)</span> and thus
<span class="math notranslate nohighlight">\(s_k n_k = 0\)</span> and the value of <span class="math notranslate nohighlight">\(s_k\)</span> <cite>= self.strides[k]</cite> is
arbitrary.</p></li>
<li><p>If a tensor has no elements (<code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">==</span> <span class="pre">0</span></code>) there is no legal
index and the strides are never used. Any array with no elements may be
considered C-style and Fortran-style contiguous.</p></li>
</ol>
</div></blockquote>
<p>Point 1. means that even a high dimensional array could be C-style and Fortran-style
contiguous at the same time.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It does <em>not</em> generally hold that <code class="docutils literal notranslate"><span class="pre">strides[-1]</span> <span class="pre">==</span> <span class="pre">sizeof(dtype)</span></code>
for C-style contiguous arrays or <code class="docutils literal notranslate"><span class="pre">strides[0]</span> <span class="pre">==</span> <span class="pre">sizeof(dtype)</span></code> for
Fortran-style contiguous tensors is true.</p>
</div>
<p>Data in new <code class="xref py py-class docutils literal notranslate"><span class="pre">tensors</span></code> is in the <span class="xref std std-term">row-major</span>
(C) order, unless otherwise specified, but, for example, <span class="xref std std-ref">basic
array slicing</span> often produces <span class="xref std std-term">views</span>
in a different scheme.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several algorithms in Bottle work on arbitrarily strided arrays.
However, some algorithms require single-segment arrays. When an
irregularly strided array is passed in to such algorithms, a copy
is automatically made.</p>
</div>
</div>
<div class="section" id="array-attributes">
<span id="tensor-ndtensor-attributes"></span><h2>Array attributes<a class="headerlink" href="#array-attributes" title="Permalink to this headline">¶</a></h2>
<p>Array attributes reflect information that is intrinsic to the array
itself. Generally, accessing an array through its attributes allows
you to get and sometimes set intrinsic properties of the array without
creating a new array. The exposed attributes are the core parts of an
array and only some of them can be reset meaningfully without creating
a new array. Information on each attribute is given below.</p>
<div class="section" id="id1">
<h3>Memory layout<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The following attributes contain information about the memory layout
of the array:</p>
</div>
<div class="section" id="data-type">
<h3>Data type<a class="headerlink" href="#data-type" title="Permalink to this headline">¶</a></h3>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">Data type objects</span></p>
</div>
<p>The data type object associated with the array can be found in the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code> attribute:</p>
</div>
<div class="section" id="other-attributes">
<h3>Other attributes<a class="headerlink" href="#other-attributes" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="array-interface">
<span id="arrays-ndarray-array-interface"></span><h3>Array interface<a class="headerlink" href="#array-interface" title="Permalink to this headline">¶</a></h3>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">arrays.interface</span>.</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_interface__</span></code></p></td>
<td><p>Python-side of the array interface</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_struct__</span></code></p></td>
<td><p>C-side of the array interface</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ctypes-foreign-function-interface">
<h3><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> foreign function interface<a class="headerlink" href="#ctypes-foreign-function-interface" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="array-methods">
<span id="array-ndarray-methods"></span><h2>Array methods<a class="headerlink" href="#array-methods" title="Permalink to this headline">¶</a></h2>
<p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> object has many methods which operate on or with
the array in some fashion, typically returning an array result. These
methods are briefly explained below. (Each method’s docstring has a
more complete description.)</p>
<p>For the following methods there are also corresponding functions in
<code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code>: <code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">argmax()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">argmin()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">argpartition()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">choose()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">clip()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">compress()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">cumprod()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">cumsum()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">diagonal()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">imag()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">min</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">partition()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">prod()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">ptp()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">put()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">ravel()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">real()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">repeat()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">reshape()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">round</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">searchsorted()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sort()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">squeeze()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">std()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">swapaxes()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">take()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">trace()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">transpose()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">var()</span></code>.</p>
<div class="section" id="array-conversion">
<h3>Array conversion<a class="headerlink" href="#array-conversion" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="shape-manipulation">
<h3>Shape manipulation<a class="headerlink" href="#shape-manipulation" title="Permalink to this headline">¶</a></h3>
<p>For reshape, resize, and transpose, the single tuple argument may be
replaced with <code class="docutils literal notranslate"><span class="pre">n</span></code> integers which will be interpreted as an n-tuple.</p>
</div>
<div class="section" id="item-selection-and-manipulation">
<h3>Item selection and manipulation<a class="headerlink" href="#item-selection-and-manipulation" title="Permalink to this headline">¶</a></h3>
<p>For array methods that take an <em>axis</em> keyword, it defaults to
<em>None</em>. If axis is <em>None</em>, then the array is treated as a 1-D
array. Any other value for <em>axis</em> represents the dimension along which
the operation should proceed.</p>
</div>
<div class="section" id="calculation">
<h3>Calculation<a class="headerlink" href="#calculation" title="Permalink to this headline">¶</a></h3>
<p id="index-3">Many of these methods take an argument named <em>axis</em>. In such cases,</p>
<ul class="simple">
<li><p>If <em>axis</em> is <em>None</em> (the default), the array is treated as a 1-D
array and the operation is performed over the entire array. This
behavior is also the default if self is a 0-dimensional array or
array scalar. (An array scalar is an instance of the types/classes
float32, float64, etc., whereas a 0-dimensional array is an ndarray
instance containing precisely one array scalar.)</p></li>
<li><p>If <em>axis</em> is an integer, then the operation is done over the given
axis (for each 1-D subarray that can be created along the given axis).</p></li>
</ul>
<div class="admonition-example-of-the-axis-argument admonition">
<p class="admonition-title">Example of the <em>axis</em> argument</p>
<p>A 3-dimensional array of size 3 x 3 x 3, summed over each of its
three axes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[ 0,  1,  2],</span>
<span class="go">        [ 3,  4,  5],</span>
<span class="go">        [ 6,  7,  8]],</span>
<span class="go">       [[ 9, 10, 11],</span>
<span class="go">        [12, 13, 14],</span>
<span class="go">        [15, 16, 17]],</span>
<span class="go">       [[18, 19, 20],</span>
<span class="go">        [21, 22, 23],</span>
<span class="go">        [24, 25, 26]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[27, 30, 33],</span>
<span class="go">       [36, 39, 42],</span>
<span class="go">       [45, 48, 51]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># for sum, axis is the first keyword, so we may omit it,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># specifying only its value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(array([[27, 30, 33],</span>
<span class="go">        [36, 39, 42],</span>
<span class="go">        [45, 48, 51]]),</span>
<span class="go"> array([[ 9, 12, 15],</span>
<span class="go">        [36, 39, 42],</span>
<span class="go">        [63, 66, 69]]),</span>
<span class="go"> array([[ 3, 12, 21],</span>
<span class="go">        [30, 39, 48],</span>
<span class="go">        [57, 66, 75]]))</span>
</pre></div>
</div>
</div>
<p>The parameter <em>dtype</em> specifies the data type over which a reduction
operation (like summing) should take place. The default reduce data
type is the same as the data type of <em>self</em>. To avoid overflow, it can
be useful to perform the reduction using a larger data type.</p>
<p>For several methods, an optional <em>out</em> argument can also be provided
and the result will be placed into the output array given. The <em>out</em>
argument must be an <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> and have the same number of
elements. It can have a different data type in which case casting will
be performed.</p>
</div>
</div>
<div class="section" id="arithmetic-matrix-multiplication-and-comparison-operations">
<h2>Arithmetic, matrix multiplication, and comparison operations<a class="headerlink" href="#arithmetic-matrix-multiplication-and-comparison-operations" title="Permalink to this headline">¶</a></h2>
<p id="index-4">Arithmetic and comparison operations on <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>
are defined as element-wise operations, and generally yield
<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> objects as results.</p>
<p>Each of the arithmetic operations (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>,
<code class="docutils literal notranslate"><span class="pre">%</span></code>, <code class="docutils literal notranslate"><span class="pre">divmod()</span></code>, <code class="docutils literal notranslate"><span class="pre">**</span></code> or <code class="docutils literal notranslate"><span class="pre">pow()</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>,
<code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">~</span></code>) and the comparisons (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>) is equivalent to the corresponding
universal function (or <span class="xref std std-term">ufunc</span> for short) in NumPy.  For
more information, see the section on <span class="xref std std-ref">Universal Functions</span>.</p>
<p>Comparison operators:</p>
<p>Truth value of an array (<code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code>):</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Truth-value testing of an array invokes
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ndarray.__bool__()</span></code>, which raises an error if the number of
elements in the array is larger than 1, because the truth value
of such arrays is ambiguous. Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">.any()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">.all()</span></code> instead to be clear about what is meant
in such cases. (If the number of elements is 0, the array evaluates
to <code class="docutils literal notranslate"><span class="pre">False</span></code>.)</p>
</div>
<p>Unary operations:</p>
<p>Arithmetic:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Any third argument to <code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code> is silently ignored,
as the underlying <code class="xref py py-func docutils literal notranslate"><span class="pre">ufunc</span></code> takes only two arguments.</p></li>
<li><p>The three division operators are all defined; <code class="xref py py-obj docutils literal notranslate"><span class="pre">div</span></code> is active
by default, <code class="xref py py-obj docutils literal notranslate"><span class="pre">truediv</span></code> is active when
<code class="xref py py-obj docutils literal notranslate"><span class="pre">__future__</span></code> division is in effect.</p></li>
<li><p>Because <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> is a built-in type (written in C), the
<code class="docutils literal notranslate"><span class="pre">__r{op}__</span></code> special methods are not directly defined.</p></li>
<li><p>The functions called to implement many arithmetic special methods
for arrays can be modified using <code class="xref py py-class docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>.</p></li>
</ul>
</div>
<p>Arithmetic, in-place:</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In place operations will perform the calculation using the
precision decided by the data type of the two operands, but will
silently downcast the result (if necessary) so it can fit back into
the array.  Therefore, for mixed precision calculations, <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">{op}=</span>
<span class="pre">B</span></code> can be different than <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">{op}</span> <span class="pre">B</span></code>. For example, suppose
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">ones((3,3))</span></code>. Then, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">3j</span></code> is different than <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span>
<span class="pre">3j</span></code>: while they both perform the same computation, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">3</span></code>
casts the result to fit back in <code class="docutils literal notranslate"><span class="pre">a</span></code>, whereas <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">3j</span></code>
re-binds the name <code class="docutils literal notranslate"><span class="pre">a</span></code> to the result.</p>
</div>
<p>Matrix Multiplication:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Matrix operators <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code> were introduced in Python 3.5
following PEP465. NumPy 1.10.0 has a preliminary implementation of <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>
for testing purposes. Further documentation can be found in the
<code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code> documentation.</p>
</div>
</div>
<div class="section" id="special-methods">
<h2>Special methods<a class="headerlink" href="#special-methods" title="Permalink to this headline">¶</a></h2>
<p>For standard library functions:</p>
<p>Basic customization:</p>
<p>Container customization: (see <span class="xref std std-ref">Indexing</span>)</p>
<p>Conversion; the operations <code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code>.
. They work only on arrays that have one element in them
and return the appropriate scalar.</p>
<p>String representations:</p>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The N-dimensional tensor</a><ul>
<li><a class="reference internal" href="#constructing-tensors">Constructing Tensors</a></li>
<li><a class="reference internal" href="#indexing-arrays">Indexing arrays</a></li>
<li><a class="reference internal" href="#internal-memory-layout-of-an-tensor">Internal memory layout of an Tensor</a></li>
<li><a class="reference internal" href="#array-attributes">Array attributes</a><ul>
<li><a class="reference internal" href="#id1">Memory layout</a></li>
<li><a class="reference internal" href="#data-type">Data type</a></li>
<li><a class="reference internal" href="#other-attributes">Other attributes</a></li>
<li><a class="reference internal" href="#array-interface">Array interface</a></li>
<li><a class="reference internal" href="#ctypes-foreign-function-interface"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> foreign function interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#array-methods">Array methods</a><ul>
<li><a class="reference internal" href="#array-conversion">Array conversion</a></li>
<li><a class="reference internal" href="#shape-manipulation">Shape manipulation</a></li>
<li><a class="reference internal" href="#item-selection-and-manipulation">Item selection and manipulation</a></li>
<li><a class="reference internal" href="#calculation">Calculation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-matrix-multiplication-and-comparison-operations">Arithmetic, matrix multiplication, and comparison operations</a></li>
<li><a class="reference internal" href="#special-methods">Special methods</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tensor.html"
                        title="previous chapter">Tensor objects</a></p>
  <h3>This Page</h3>
  <div>
    <a href="_sources/tensor.ndtensor.rst.txt"
       rel="nofollow">Show Source</a>
  </div>
<div class="this-page-menu">
  <a href="/scipy/docs/scipy-docs/tensor.ndtensor.rst.rst">Edit page</a>
</div>

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2019, Chris Zimmerman.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.2.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>